#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using ii = pair<int, int>;
const char nl = '\n';

int main()
{
    cin.tie(nullptr); ios::sync_with_stdio(false);

    // Step 1: รับอินพุตสำหรับจำนวน contest (c) และจำนวน problem (p)
    int c, p;
    cin >> c >> p;
    // สำหรับแต่ละ contest เก็บคู่ (m, s): m = คุณภาพขั้นต่ำ, s = ความพึงพอใจ
    vector<ii> contests(c);
    for (int i = 0; i < c; i++)
    {
        cin >> contests[i].first >> contests[i].second;
    }

    // Step 2: วิเคราะห์โจทย์จาก flowchart
    // โจทย์นี้เป็นแบบ "Greedy" โดยแต่ละปัญหาจะเลือก contest ที่ให้ s สูงสุด
    // โดยมีเงื่อนไขว่าปัญหานั้นต้องมีคุณภาพ q >= m ของ contest นั้น

    // Step 3: Preprocess contests ด้วยการ sort ตามค่า m (คุณภาพขั้นต่ำ)
    sort(contests.begin(), contests.end());
    
    // สร้าง prefix maximum array เพื่อเก็บค่าสูงสุดของ s ที่พบในช่วง [0, i]
    vector<int> prefix(c);
    for (int i = 0; i < c; i++)
    {
        if(i == 0) {prefix[i] = contests[i].second;}
        else {prefix[i] = max(prefix[i-1], contests[i].second);}
    }

    // Step 4: ประมวลผลสำหรับแต่ละ problem
    // สำหรับ problem แต่ละข้อ เราจะใช้ binary search เพื่อหาตำแหน่ง contest สุดท้าย
    // ที่มี m <= q ของ problem นั้น จากนั้นเลือก s ที่ดีที่สุด (จาก prefix array)
    ll ans = 0;
    for (int i = 0; i < p; i++)
    {
        int q, d;
        cin >> q >> d; // q = คุณภาพของ problem, d = ความเสียหายที่เกิดขึ้นเมื่อส่ง
        // หาตำแหน่ง index ที่ contest มี m <= q โดยใช้ upper_bound
        int idx = upper_bound(contests.begin(), contests.end(), make_pair(q, INT_MAX)) - contests.begin() - 1;
        if(idx >= 0){
            int bestS = prefix[idx];  // s ที่ดีที่สุดสำหรับ contest ที่มี m <= q
            // คำนวณกำไรสุทธิ ถ้า bestS - d > 0 ให้บวกเข้าคำตอบ
            if(bestS > d) {ans += (bestS - d);}
        }
    }
    // Step 5: พิมพ์ผลลัพธ์ (ผลรวมความพึงพอใจสุทธิที่มากที่สุด)
    cout << ans << nl;
    return 0;
}
